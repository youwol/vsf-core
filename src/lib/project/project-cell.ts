import { BehaviorSubject, from, ReplaySubject } from 'rxjs'
import { Journal } from '@youwol/logging'
import { VirtualDOM } from '@youwol/flux-view'

import { Immutable, Immutables } from '../common'
import { Configurations } from '..'
import { ProjectState, Environment } from './'

/**
 * Cell function signature for {@link JsCell}
 */
export type CellFunction = (d: {
    project: Immutable<ProjectState>
    cell: JsCell
    env: Immutable<Environment>
}) => Promise<Immutable<ProjectState>>

/**
 * Trait for cells
 */
export interface CellTrait {
    /**
     * Execute the cell and return a promise on the updated {@link ProjectState}.
     *
     * @param project
     * @return new project, it is immutable because it can be the original project.
     */
    execute(project: Immutable<ProjectState>): Promise<Immutable<ProjectState>>
}

/**
 * Implementation of {@link CellTrait} based on a javascript {@link CellFunction}.
 */
export class JsCell implements CellTrait {
    /**
     * source code of the cell
     *
     * @group Immutable Properties
     */
    public readonly source: Configurations.JsCode<CellFunction>
    /**
     * outputs generated by the cell
     *
     * @group Observables
     */
    public readonly outputs$ = new ReplaySubject<VirtualDOM>()

    /**
     * Views factory used when calling {@link log}
     */
    public readonly viewsFactory: Immutable<Journal.DataViewsFactory> = []

    constructor(params: {
        source: Configurations.JsCode<CellFunction>
        viewsFactory?: Immutable<Journal.DataViewsFactory>
    }) {
        Object.assign(this, params)
    }

    /**
     * Execute the cell
     * @param project initial project state
     * @return updated project state
     */
    execute(
        project: Immutable<ProjectState>,
    ): Promise<Immutable<ProjectState>> {
        return this.source
            .execute({ project, cell: this, env: project.environment })
            .then((project) => {
                this.outputs$.next({ class: 'fas fa-check fv-text-success' })
                this.outputs$.complete()
                return project
            })
    }

    /**
     * Display elements - string or virtual DOM - in cell's {@link outputs$}.
     * @param args list of elements
     */
    display(...args: (VirtualDOM | string)[]) {
        this.outputs$.next({
            class: 'd-flex align-items-center',
            children: args.map((view) => {
                const vDOM = typeof view == 'string' ? stringView(view) : view
                return {
                    class: 'pr-2',
                    children: [vDOM],
                }
            }),
        })
    }

    /**
     * Log elements - string or unknown - in cell's {@link outputs$}.
     * Use {@link Environment.viewsFactory}.
     * @param args list of elements
     */
    log(...args: (string | unknown)[]) {
        const allViews = args
            .map((data) => {
                return typeof data == 'string'
                    ? stringView(data)
                    : this.viewsFactory
                          .filter((view) => view.isCompatible(data))
                          .map((fact) => fact.view(data))
            })
            .flat()
        from(allViews).subscribe((view) => {
            if (view instanceof Promise) {
                view.then((v) => {
                    this.outputs$.next({ children: [v] })
                })
                return
            }
            this.outputs$.next(view)
        })
    }
}

function stringView(data: string | boolean | number) {
    return {
        class: 'fv-text-focus',
        innerHTML: `<b>${data}</b>`,
    }
}

/**
 * Generic specification of a {@link ProjectState} store.
 */
export type ProjectsStore<T> = Map<T, Immutable<ProjectState>>

export function insertCell<Cell extends CellTrait>({
    cells,
    cellRef,
    newCell,
    where,
    store,
    statePreserved,
}: {
    cells: Immutables<Cell>
    cellRef: Immutable<Cell>
    newCell: Immutable<Cell>
    where: 'after' | 'before'
    store: Immutable<ProjectsStore<Cell>>
    statePreserved: boolean
}): { newStore: ProjectsStore<Immutable<Cell>>; newCells: Immutable<Cell>[] } {
    const indexInsert =
        where == 'after' ? cells.indexOf(cellRef) + 1 : cells.indexOf(cellRef)
    const newCells = [...cells]
    newCells.splice(indexInsert, 0, newCell)
    const newStore = new Map(store) as ProjectsStore<Immutable<Cell>>
    if (indexInsert <= cells.length - 1 && newStore.has(cells[indexInsert])) {
        // In this path - if not inserted as last cell and state available - => set the ref. state.
        // Otherwise, ref. state is not set => will be initialized upon new cell's execution
        newStore.set(newCell, newStore.get(cells[indexInsert]))
    }
    // No need to 'reset' states of following cells if the new cell does preserve the project
    if (statePreserved) {
        return {
            newStore,
            newCells,
        }
    }
    const afterCells = newCells.slice(newCells.indexOf(newCell) + 1)
    // If it does not preserves => remove states of subsequent cells
    afterCells.forEach((cell) => {
        newStore.delete(cell)
    })
    return {
        newStore,
        newCells,
    }
}

/**
 * A batch of {@link CellTrait}.
 */
export class BatchCells implements CellTrait {
    /**
     * The cells of the batch.
     *
     * @group Immutable Properties
     */
    public readonly cells: CellTrait[]
    /**
     * Observable over the associated {@link ProjectsStore}.
     *
     * ⚠️ For a particular cell ({@link CellTrait}), the project associated
     * corresponds to the **initial state**; i.e. before execution of the cell.
     *
     * @group Observables
     */
    public readonly projectsStore$: BehaviorSubject<ProjectsStore<CellTrait>>

    /**
     *
     * @param params.cells cells of the batch
     * @param params.projectsStore$ initial {@link projectsStore$}
     */
    constructor(params: {
        cells: CellTrait[]
        projectsStore$: BehaviorSubject<Immutable<ProjectsStore<CellTrait>>>
    }) {
        Object.assign(this, params)
    }

    /**
     * Execute in the right order the {@link cells} starting with
     * the last cell that has no associated entry in the {@link projectsStore$}.
     *
     * Each time a cell is executed, the resulting {@link ProjectState} is emitted
     * as a new entry in {@link projectsStore$} for the next cell:
     * it corresponds to the 'starting state', **before** its execution.
     *
     * @param defaultProject
     * @return a promise of the {@link ProjectState} resulting from the execution of the last cell.
     */
    execute(
        defaultProject: Immutable<ProjectState>,
    ): Promise<Immutable<ProjectState>> {
        const projectsStore0 = this.projectsStore$.value
        if (this.cells.length == 0) {
            return Promise.resolve(defaultProject)
        }
        const currentCell =
            this.cells.length > 1
                ? this.cells[this.cells.length - 1]
                : undefined
        if (currentCell && projectsStore0.has(currentCell)) {
            return currentCell
                .execute(projectsStore0.get(currentCell))
                .then((project) => project)
        }
        if (this.cells.length == 1) {
            return this.cells[0]
                .execute(defaultProject)
                .then((project) => project)
        }
        const batch = new BatchCells({
            cells: this.cells.slice(0, -1),
            projectsStore$: this.projectsStore$,
        })
        return batch
            .execute(defaultProject)
            .then((project) => {
                const projectsStore = this.projectsStore$.value
                const newStore = new Map(projectsStore)
                newStore.set(this.cells.slice(-1)[0], project)
                this.projectsStore$.next(newStore)
                return project
            })
            .then(() => {
                return this.execute(defaultProject)
            })
    }
}
